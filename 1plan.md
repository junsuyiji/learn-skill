# 2023.10.8

## OS

怎么管理空闲的空间？

面临的困境：如果是空闲空间的大小的是确定，那样就会很容易进行管理，但是如果空间有的大有的小，这样就会很难确定，管理的时候就会很麻烦

**什么操作会导致空闲空间的大小不一定**

- 用户级内存分配库，例如`malloc/free`
- 分段式内存管理

例子：用户级内存分配库是怎么把空间弄碎的？

假如现在有连续的内存空间`0到30kb`，现在有一个`malloc`把10到20这个地方的内存分配给了一个对象。现在内存有0到10和20到30，虽然看起来有了20kb，但是其实连11kb都分配不了，因为两个内存不在一块。其实你把10到20在地方在重新换回来也不行，因为那样就变成了3个10kb的大小的块。把这个三个内存合并可以解决这个问题



管理空闲内存空间的理想是，**既能够快速的分配一个内存块，还能够让内存碎片最小化**

常见的空闲内存空间管理的算法

- 最有匹配(best fit)：遍历空闲空间，找到符合当前需要的最小的内存块，然后分配
- 最差匹配(worst fit) : 和上面相反，这个是找到当前最大的内存块，然后进行分割给当前进程需要的空间，然后余下的空间假如空间链表
- 首次匹配(first fit): 从头开始找到比需要的内存大于或者等于的空间，然后就分割
- 下次匹配(next fit):分割方式和首次匹配一样，但是不同于首次匹配从头开始寻找，下次匹配从上次结束的地方开始寻找



其实看来看去还是发现如果空闲空间的大小是确定，那样会比较容易进行内存管理



**如何通过页来实现虚拟内存的管理**



页表(page_table)：为地址空间的每一个虚拟页面保存地址转换，从而让我们知道每个页在物理内存中的位置。**每一个进程都有独立的页表**

例子：页表转换的例子

设进程A有64字节的地址空间，页大小为16字节

`movl <virtual_address>, %eax`

虚拟地址可以拆成两个部分：虚拟页面号(virtual page_number，VPN)和页内的偏移量(offset)

1. 地址空间是64字节，$2^6=64$,所以6个2进制位已经可以覆盖整个地址空间
2. 虚拟地址从高到低分别是$v_5,v_4,v_3,v_2,v_1,v_0$
3. 页的大小是16字节，$2^4=16$
4. 如果虚拟地址的低位作为4个字节 ，那么$v_3到v_0$,就是offset
5. 假设VPN=21=010101,虚拟页01对应的是真实的第七页
6. 那么在真实内存的第七页找到16个字节处就是真实的物理地址





**问题：页表在哪里存放？页表有多大？采用分页会不会让操作系统变慢**

页表存储在内存中

页表可以很大，也可以很小，主要是根据页表项的数量决定的

分页会导致操作系统变慢



为什么页表会变得很大？

例如：32位的地址空间，页的大小是4kb，虚拟地址是32位，20位是VPN，12位是offset

一个20位的VPN意味着操作系统要为每个进程维护$2^{20}$个操作转换（大约一百万），然后一个页表项是4字节，那么每个页表就是需要4MB，那么如果有一百个进程，仅仅维护页表的开销就高达400MB，这是不可以接受的



为什么会变慢

操作系统首先要从进程中的页表中找到页表项，然后执行转换，然后访问物理内存

首先访问内存，然后进行计算，然后访问内存确实有点慢



面临的问题

所以现在模式虽然可以很好的管理内存的空闲空间，但是页表也会让内存变慢，不仅如果还会占用大量的内存



**如何加速地址转换，尽量避免额外的内存访问**

TLB：地址转换旁路缓冲器



TLB硬件算法：

1. 从虚拟地址中提取VPN `VPN = (virtual_adress & VPN_MASK) >> SHIFT`
2. 检查TLB是否有该VPN的转换映射`(success,TlbEntry) = TLB_lookup(VPN)`
3. 若有则TLB命中，意味着改页在TLB里有转换映射，于是可以从TLB项里取出页帧号(PFN)，和offset形成物理地址(PA)
4. 如果没有命中，访问页表找转换映射，并且更新TLB

例子

|      | 0    | 1    |
| ---- | ---- | ---- |
| 2    | 3    | 4    |
| 5    | 6    |      |



假如在如上所示的内存中存储了这一些东西，我们可以看出命中率是0101101 

如果列增多，可以提高缓存率，这主要得益于缓存的局部性





**问题：TLB仅仅对当前的进程有效，请问如果现在操作系统切换内存了，怎么办**

方案一：简单的清空tlb，但是这样下次访问的时候，代价会变高

方案二：添加一个标志位ASID，以此来显示当前的转换是哪一个进程的





## c++

线程数量是怎么确定的

为什么不可以什么时候用到线程什么时候创建线程？

线程的4点消耗



用户态为什么没有资格创建线程？

操作系统对于用户来说是透明的，。。。。





线程的数量是怎么进行确定的？

根据cpu的数量确定的



线程池的两种模式：

fixed模式：线程的数量固定不变，根据cpu的核心数量来确定的



cached模式：根据当前的需求，动态增长





# 2023.10.9

## c++

线程同步的两个方面：互斥和通信



**互斥**

当多个线程的同时访问一个临界区的时候，就会产生数据竞争的问题

例子：线程A和线程B同时执行`sum++`,如果A的操作没有完成之前，B 修改了sum的值，将会导致错误的结果

```C
#include <stdio.h>
#include <pthread.h>

#define N 10000


long sum = 0;

void *Tsum()
{
  for (int i = 0; i < N; i++){
    sum++;
  }
}

int main() 
{
  pthread_t  test1,test2;

  pthread_create(&test1, NULL, Tsum, NULL);
  pthread_create(&test2, NULL, Tsum, NULL);
  
  pthread_join(test1,NULL);
  pthread_join(test2,NULL);
  printf("%ld\n", sum);

  return 0;
}

```



为了避免这种情况通常都是加上锁，这样就能够实现临界区的保护

```c
#include <stdio.h>
#include <pthread.h>

#define N 10000

pthread_mutex_t mutex;

long sum = 0;

void *Tsum()
{
  for (int i = 0; i < N; i++){
    pthread_mutex_lock(&mutex);
    sum++;
    pthread_mutex_unlock(&mutex);
  }
}

int main() 
{
  pthread_t  test1,test2;
  pthread_mutex_init(&mutex, NULL);

  pthread_create(&test1, NULL, Tsum, NULL);
  pthread_create(&test2, NULL, Tsum, NULL);
  
  pthread_join(test1,NULL);
  pthread_join(test2,NULL);
  printf("%ld\n", sum);

  return 0;
}

```



**通信**

线程通信，一般来说使用条件变量或者信号量来进行通信

例子：打印合理的括号,现在有进程A和进程B两个进程，请问怎么满足打印出来的括号是合理的括号

比如`()`

